/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
 * Copyright 2008-2010 Pelican Mapping
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */

#ifndef OSGEARTH_IMAGEUTILS_H
#define OSGEARTH_IMAGEUTILS_H

#include <osgEarth/Common>
#include <osg/Image>

namespace osgEarth
{
    class OSGEARTH_EXPORT ImageUtils
    {
    public:
        /**
         * Copys a portion of one image into another.
         */
        static bool copyAsSubImage(
            const osg::Image* src, 
            osg::Image* dst, 
            int dst_start_col, int dst_start_row, int dst_start_img=0 );

        /**
         * Resizes an image using nearest-neighbor resampling. Returns a new image, leaving
         * the input image unaltered.
         *
         * Note. If the output parameter is NULL, this method will allocate a new image and
         * resize into that new image. If the output parameter is non-NULL, this method will
         * assume that the output image is already allocated to the proper size, and will
         * do a resize+copy into that image. In the latter case, it is your responsibility
         * to make sure the output image is allocated to the proper size and with the proper
         * pixel configuration (it must match that of the input image).
         *
         * If the output parameter is non-NULL, then the mipmapLevel is also considered.
         * This lets you resize directly into a particular mipmap level of the output image.
         */
        static bool resizeImage(
            const osg::Image* input, 
            unsigned int new_s, unsigned int new_t,
            osg::ref_ptr<osg::Image>& output,
            unsigned int mipmapLevel =0 );

        /**
         * Crops the input image to the dimensions provided and returns a
         * new image. Returns a new image, leaving the input image unaltered.
         * Note:  The input destination bounds are modified to reflect the bounds of the
         *        actual output image.  Due to the fact that you cannot crop in the middle of a pixel
         *        The specified destination extents and the output extents may vary slightly.
         *@param src_minx
         *       The minimum x coordinate of the input image.
         *@param src_miny
         *       The minimum y coordinate of the input image.
         *@param src_maxx
         *       The maximum x coordinate of the input image.
         *@param src_maxy
         *       The maximum y coordinate of the input image.
         *@param dst_minx
         *       The desired minimum x coordinate of the cropped image.
         *@param dst_miny
         *       The desired minimum y coordinate of the cropped image.
         *@param dst_maxx
         *       The desired maximum x coordinate of the cropped image.
         *@param dst_maxy
         *       The desired maximum y coordinate of the cropped image.
         */
        static osg::Image* cropImage(
            const osg::Image* image,
            double src_minx, double src_miny, double src_maxx, double src_maxy,
            double &dst_minx, double &dst_miny, double &dst_maxx, double &dst_maxy);

        /**
         * Creates an Image that "blends" two images into a new image in which "primary"
         * occupies mipmap level 0, and "secondary" occupies all the other mipmap levels.
         *
         * WARNING: this method assumes that primary and seconday are the same exact size
         * and the same exact format.
         */
        static osg::Image* createMipmapBlendedImage(
            const osg::Image* primary,
            const osg::Image* secondary );

        /**
         * Blends the "src" image into the "dest" image, based on the "a" value.
         * The two images must be the same.
         */
        static bool mix( osg::Image* dest, const osg::Image* src, float a );

        /**
         * Creates and returns a copy of the input image after applying a
         * sharpening filter. Returns a new image, leaving the input image unaltered.
         */
        static osg::Image* sharpenImage( const osg::Image* image );

        /**
         * Gets whether the input image's dimensions are powers of 2.
         */
        static bool isPowerOfTwo(const osg::Image* image);

        /**
         * Gets a transparent, single pixel image used for a placeholder
         */
        static osg::Image* createEmptyImage();

		/**
		 *Converts the given image to RGB8
		 */
		static osg::Image* convertToRGB8(const osg::Image* image);

		/**
		 *Converts the given image to RGBA8
		 */
		static osg::Image* convertToRGBA8(const osg::Image* image);

		/**
		 *Compares the image data of two images and determines if they are equivalent
		 */
		static bool areEquivalent(const osg::Image *lhs, const osg::Image *rhs);

        /**
         * Gets the color of an image at the specified pixel. Works for packed pixel
         * formats as well as standard formats (osg::Image::getColor only works for
         * standard formats)
         * DEPRECATED
         */
        static osg::Vec4 getColor(const osg::Image* image, int s, int t, int r =0);		

        /**
         * Sets the color of a pixel in an image.
         * DEPRECATED
         */
        static bool setColor(osg::Image* image, int s, int t, int r, const osg::Vec4& color);

        /**
         * Whether two colors are roughly equivalent.
         */
        static bool areRGBEquivalent( const osg::Vec4& lhs, const osg::Vec4& rhs, float epsilon =0.01f ) {
            return
                fabs(lhs.r() - rhs.r()) < epsilon &&
                fabs(lhs.g() - rhs.g()) < epsilon &&
                fabs(lhs.b() - rhs.b()) < epsilon;
        }
                   

        /**
         * Checks whether the image has an alpha component 
         */
        static bool hasAlphaChannel( const osg::Image* image );


        /**
         * Reads color data out of an image, regardles of its internal pixel format.
         */
        class OSGEARTH_EXPORT PixelReader
        {
        public:
            PixelReader(const osg::Image* image);

            osg::Vec4 operator()(int s, int t, int r = 0) const
            {
                return (*_reader)(this, s, t, r);
            }
            const osg::Image* _image;
            unsigned _colMult;
            unsigned _rowMult;
            unsigned _imageSize;
            const unsigned char* data(int s, int t, int r) const {
                return _image->data() + s * _colMult + t * _rowMult + r * _imageSize;
            }
            typedef osg::Vec4 (*ReaderFunc)(const PixelReader* ia, int s, int t, int r);
            ReaderFunc _reader;
        };
        
        /**
         * Writes color data to an image, regardles of its internal pixel format.
         */
        class OSGEARTH_EXPORT PixelWriter
        {
        public:
            PixelWriter(osg::Image* _image);

            void operator()(int s, int t, int r, const osg::Vec4& c)
            {
                (*_writer)(this, s, t, r, c );
            }

            osg::Image* _image;
            unsigned _colMult;
            unsigned _rowMult;
            unsigned _imageSize;

            unsigned char* data(int s, int t, int r) const {
                return _image->data() + s * _colMult + t * _rowMult + r * _imageSize;
            }

            typedef void (*WriterFunc)(const PixelWriter* iw, int s, int t, int r, const osg::Vec4& c);
            WriterFunc _writer;
        };

        struct PixelVisitor
        {
            virtual bool operator()(osg::Vec4f& in_out_pixel) =0;

            void accept( osg::Image* image ) {
                PixelReader _reader( image );
                PixelWriter _writer( image );
                for( int r=0; r<image->r(); ++r ) {
                    for( int t=0; t<image->t(); ++t ) {
                        for( int s=0; s<image->s(); ++s ) {
                            osg::Vec4f pixel = _reader(s,t,r);
                            if ( operator()(pixel) )
                                _writer(s,t,r,pixel);
                        }
                    }
                }
            }

            void accept( const osg::Image* src, osg::Image* dest ) {
                PixelReader _reader( src );
                PixelWriter _writer( dest );
                for( int r=0; r<src->r(); ++r ) {
                    for( int t=0; t<src->t(); ++t ) {
                        for( int s=0; s<src->s(); ++s ) {
                            osg::Vec4f pixel = _reader(s,t,r);
                            if ( operator()(pixel) )
                                _writer(s,t,r,pixel);
                        }
                    }
                }
            }
        };
    };
}

#endif //OSGEARTH_IMAGEUTILS_H
